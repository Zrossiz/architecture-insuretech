Создаем отдельный сервис, который будет заниматься агреграцией информации по осаго
Когда фронт отправляет запроос - ему возвращается request id. При помощи request id фронт будет пулить раз в 2-5 секунд информацию по страховкам и отображать ее.
Когда фронт отправляет запрос в сервис osago-aggregator - он создает request id и прикрепляет к нему записи компаний, которые ответили.
Обновляет osago-aggregator данные о записях при помощи pooling

- Требуется ли свое хранилище?
Да, если особо нагрузки не будет - используем postgresql. Если нужно быстрее - можем хранить в redis

- Какой API он предоставляет core-app?
Создание заказа, возвращая request id
Получение статуса заказа по request id, в ответ возвращаются одобренные статусы

- Определите средство интеграции между сервисами core-app и osago-aggregator.
HTTP REST, если нагрузка небольшая. Можно добавить grpc, если не хватает скорости

- Подумайте над API для веб-приложения в core-app.
Создание заказа
Поулчение статуса заказа по request id

- Определите средство интеграции между веб-приложением и core-app. Если будете использовать средство, отличное от REST, отразите интеграцию новой стрелкой.
Будем использовать rest. Веб пулингом ходит к core-app, core-app сразу идет в osago-aggregator. osago-aggregator идет пуллингом

- В зависимости от выбранных средств интеграции подумайте, требуется ли где-то применение паттернов отказоустойчивости:
Rate Limiting,
Circuit Breaker,
Retry,
Timeout.
Нужен таймаут. retry будет автоматически реализован при реализации pooling. rate limiting не вижу смысла добавлять, это же клиент инициирует запросы. Автоматический выключатель можно использовать, если мы получим хотя бы раз 500 ошибку от какого-то сервиса, но это вообще незначительно требование

- Примите во внимание, что сервисы задеплоены в нескольких экземплярах. Подумайте, зависит ли ваше решение от этого.
Да особо без разницы, это же поды будут ходить друг к другу, а не напрямую. Если этого нет - надо завернуть в кубер
